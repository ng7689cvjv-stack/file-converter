<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Convert files without losing quality. Runs entirely in your browser." />
  <title>CONVERT v2.4</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Instrument+Serif:ital@0;1&family=Geist:wght@300;400;500;600&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>


  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --cream: #F5F0E8;
      --cream-dark: #EDE7D9;
      --ink: #1A1814;
      --ink-mid: #4A453D;
      --ink-light: #9A9288;
      --accent: #E8460A;
      --accent-pale: #FDE8DF;
      --grid: #E0D9CE;
      --success: #2C6E49;
      --radius: 3px;
    }

    html { scroll-behavior: smooth; }

    body {
      font-family: 'Geist', sans-serif;
      background: var(--cream);
      color: var(--ink);
      min-height: 100vh;
      font-size: 14px;
      line-height: 1.5;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(var(--grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: 0.4;
      pointer-events: none;
      z-index: 0;
    }

    header {
      position: relative;
      z-index: 10;
      border-bottom: 1px solid var(--ink);
      padding: 0 40px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      background: var(--cream);
    }

    .logo {
      font-family: 'DM Mono', monospace;
      font-weight: 500;
      font-size: 13px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    .logo span { color: var(--accent); }

    .header-meta {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      color: var(--ink-light);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    main {
      position: relative;
      z-index: 1;
      max-width: 980px;
      margin: 0 auto;
      padding: 72px 40px 120px;
    }

    .headline {
      margin-bottom: 56px;
    }

    .headline h1 {
      font-family: 'Instrument Serif', serif;
      font-size: clamp(48px, 8vw, 84px);
      font-weight: 400;
      line-height: 0.95;
      letter-spacing: -0.02em;
      margin-bottom: 20px;
    }

    .headline h1 em {
      font-style: italic;
      color: var(--ink-mid);
    }

    .headline p {
      font-size: 15px;
      color: var(--ink-mid);
      max-width: 440px;
      line-height: 1.65;
      font-weight: 300;
    }

    /* FORMAT TAGS */
    .formats-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 40px;
    }

    .format-tag {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 3px 9px;
      border: 1px solid currentColor;
      border-radius: var(--radius);
    }

    .format-tag.image { color: var(--accent); }
    .format-tag.text  { color: var(--ink-mid); }
    .format-tag.pdf   { color: #7B3F9E; }

    /* DROP ZONE */
    #drop-zone {
      border: 1.5px dashed var(--ink);
      border-radius: var(--radius);
      padding: 56px 48px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s ease;
      background: var(--cream);
      margin-bottom: 32px;
    }

    #drop-zone:hover, #drop-zone.drag-over {
      border-color: var(--accent);
      border-style: solid;
      background: var(--accent-pale);
    }

    #drop-zone.drag-over { transform: scale(1.005); }

    .drop-icon {
      width: 44px;
      height: 44px;
      margin: 0 auto 16px;
      border: 1.5px solid var(--ink);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.15s;
    }

    #drop-zone:hover .drop-icon, #drop-zone.drag-over .drop-icon { border-color: var(--accent); }
    #drop-zone:hover .drop-icon svg, #drop-zone.drag-over .drop-icon svg { color: var(--accent); }

    .drop-title {
      font-family: 'Instrument Serif', serif;
      font-size: 22px;
      margin-bottom: 6px;
    }

    .drop-sub {
      font-size: 13px;
      color: var(--ink-light);
      margin-bottom: 20px;
    }

    .btn-browse {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 10px 20px;
      background: var(--ink);
      color: var(--cream);
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      transition: background 0.15s;
    }

    .btn-browse:hover { background: var(--accent); }
    #file-input { display: none; }

    /* QUEUE */
    #queue { display: flex; flex-direction: column; gap: 2px; }

    .file-item {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      align-items: center;
      gap: 12px;
      padding: 13px 18px;
      background: white;
      border: 1px solid var(--grid);
      border-radius: var(--radius);
      animation: slideIn 0.18s ease;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .file-info { min-width: 0; }
    .file-name {
      font-size: 13px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .file-meta {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      color: var(--ink-light);
      margin-top: 2px;
    }

    .format-select {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 6px 24px 6px 10px;
      border: 1px solid var(--ink);
      border-radius: var(--radius);
      background: var(--cream);
      color: var(--ink);
      cursor: pointer;
      outline: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%231A1814'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-color: var(--cream);
    }

    .quality-wrap {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .quality-wrap label {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      color: var(--ink-light);
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .quality-wrap input[type=range] {
      width: 56px;
      accent-color: var(--accent);
      cursor: pointer;
    }

    .quality-val {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      color: var(--accent);
      min-width: 26px;
    }

    .file-status {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      padding: 3px 8px;
      border-radius: var(--radius);
      white-space: nowrap;
    }

    .file-status.ready      { background: var(--cream-dark); color: var(--ink-mid); }
    .file-status.converting { background: #FFF3CD; color: #856404; }
    .file-status.done       { background: #D1FAE5; color: var(--success); }
    .file-status.error      { background: var(--accent-pale); color: var(--accent); }

    .btn-remove {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--ink-light);
      padding: 4px;
      display: flex;
      align-items: center;
      transition: color 0.15s;
      flex-shrink: 0;
    }

    .btn-remove:hover { color: var(--accent); }

    /* ACTIONS */
    #actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 24px;
      align-items: center;
    }

    .btn-primary {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 12px 28px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-primary:hover:not(:disabled) { background: #C93A06; transform: translateY(-1px); }
    .btn-primary:disabled { background: var(--ink-light); cursor: not-allowed; }

    .btn-secondary {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 12px 22px;
      background: transparent;
      color: var(--ink);
      border: 1.5px solid var(--ink);
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.15s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-secondary:hover:not(:disabled) { background: var(--ink); color: var(--cream); }
    .btn-secondary:disabled { opacity: 0.4; cursor: not-allowed; }

    .queue-count {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      color: var(--ink-light);
      margin-left: auto;
    }

    /* PROGRESS */
    #progress-wrap {
      height: 2px;
      background: var(--grid);
      border-radius: 2px;
      margin-top: 16px;
      overflow: hidden;
      display: none;
    }

    #progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.25s ease;
    }

    /* PDF PAGES MODAL */
    #pdf-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(26,24,20,0.7);
      z-index: 100;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    #pdf-modal.open { display: flex; }

    .modal-box {
      background: var(--cream);
      border: 1px solid var(--ink);
      border-radius: var(--radius);
      padding: 36px;
      max-width: 480px;
      width: 90%;
    }

    .modal-title {
      font-family: 'Instrument Serif', serif;
      font-size: 24px;
      margin-bottom: 8px;
    }

    .modal-sub {
      font-size: 13px;
      color: var(--ink-mid);
      margin-bottom: 24px;
    }

    .modal-field label {
      display: block;
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--ink-mid);
      margin-bottom: 6px;
    }

    .modal-field input, .modal-field select {
      width: 100%;
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      padding: 10px 12px;
      border: 1px solid var(--ink);
      border-radius: var(--radius);
      background: white;
      color: var(--ink);
      margin-bottom: 16px;
      outline: none;
    }

    .modal-actions { display: flex; gap: 10px; margin-top: 8px; }

    /* INFO GRID */
    .info-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1px;
      background: var(--ink);
      border: 1px solid var(--ink);
      border-radius: var(--radius);
      overflow: hidden;
      margin-top: 72px;
    }

    .info-cell { background: var(--cream); padding: 24px 20px; }

    .info-cell-num {
      font-family: 'Instrument Serif', serif;
      font-size: 36px;
      color: var(--accent);
      line-height: 1;
      margin-bottom: 6px;
    }

    .info-cell-label {
      font-size: 12px;
      color: var(--ink-mid);
      line-height: 1.5;
    }

    /* FOOTER */
    footer {
      position: relative;
      z-index: 1;
      border-top: 1px solid var(--ink);
      padding: 18px 40px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .footer-note {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      color: var(--ink-light);
      letter-spacing: 0.06em;
    }

    .footer-note a { color: var(--ink); text-decoration: none; }
    .footer-note a:hover { color: var(--accent); }

    /* ERROR LOG */
    #error-log {
      margin-top: 16px;
      display: none;
      flex-direction: column;
      gap: 2px;
    }

    .error-log-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 14px;
      background: var(--ink);
      border-radius: var(--radius) var(--radius) 0 0;
    }

    .error-log-title {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .error-log-clear {
      font-family: 'DM Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--ink-light);
      background: none;
      border: none;
      cursor: pointer;
    }

    .error-log-clear:hover { color: var(--cream); }

    #error-entries {
      background: #0F0D0B;
      border: 1px solid var(--ink);
      border-top: none;
      border-radius: 0 0 var(--radius) var(--radius);
      padding: 12px 14px;
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .error-entry {
      font-family: 'DM Mono', monospace;
      font-size: 11px;
      line-height: 1.5;
      color: #FF6B4A;
    }

    .error-entry .error-file {
      color: var(--ink-light);
      margin-right: 8px;
    }

    .error-entry .error-step {
      color: #FFC107;
      margin-right: 8px;
    }

    /* TOAST */
    #toast {
      position: fixed;
      bottom: 28px;
      left: 50%;
      transform: translateX(-50%) translateY(80px);
      background: var(--ink);
      color: var(--cream);
      font-family: 'DM Mono', monospace;
      font-size: 12px;
      letter-spacing: 0.06em;
      padding: 12px 24px;
      border-radius: var(--radius);
      z-index: 200;
      transition: transform 0.25s cubic-bezier(0.16, 1, 0.3, 1);
      pointer-events: none;
    }

    #toast.show { transform: translateX(-50%) translateY(0); }

    /* RESPONSIVE */
    @media (max-width: 700px) {
      header { padding: 0 20px; }
      main { padding: 48px 20px 80px; }
      footer { padding: 16px 20px; flex-direction: column; gap: 6px; text-align: center; }
      .file-item { grid-template-columns: 1fr auto; grid-template-rows: auto auto auto; }
      .file-info { grid-column: 1; }
      .btn-remove { grid-column: 2; grid-row: 1; }
      .format-select { grid-column: 1; }
      .quality-wrap { grid-column: 1 / -1; }
      .file-status { display: none; }
      .info-grid { grid-template-columns: repeat(2, 1fr); }
      #actions { flex-direction: column; align-items: flex-start; }
      .queue-count { margin-left: 0; }
    }
  </style>
</head>
<body>

<!-- PDF options modal -->
<div id="pdf-modal">
  <div class="modal-box">
    <div class="modal-title">PDF → Images</div>
    <div class="modal-sub" id="pdf-modal-sub">Choose output options for this PDF.</div>
    <div class="modal-field">
      <label>Output format</label>
      <select id="pdf-out-fmt">
        <option value="PNG">PNG (lossless)</option>
        <option value="JPEG" selected>JPEG (q=95)</option>
        <option value="WEBP">WebP (q=95)</option>
      </select>
    </div>
    <div class="modal-field">
      <label>Resolution (DPI)</label>
      <input type="number" id="pdf-dpi" value="150" min="72" max="600" step="1" />
    </div>
    <div class="modal-field">
      <label>Pages (e.g. 1-3, 5 or leave blank for all)</label>
      <input type="text" id="pdf-pages" placeholder="All pages" />
    </div>
    <div class="modal-actions">
      <button class="btn-primary" id="pdf-confirm-btn">Confirm</button>
      <button class="btn-secondary" id="pdf-cancel-btn">Cancel</button>
    </div>
  </div>
</div>

<header>
  <div class="logo">CONVERT<span>·</span> <span style="color:var(--ink-light);font-weight:400;">v2.4</span></div>
  <div class="header-meta">Client-side · Private · No upload</div>
</header>

<main>
  <div class="headline">
    <h1>Convert<br/><em>anything.</em></h1>
    <p>Files convert entirely in your browser — nothing leaves your device. Batch download as ZIP. Maximum quality at every step.</p>
  </div>

  <div class="formats-bar" id="formats-bar"></div>

  <div id="drop-zone">
    <div class="drop-icon">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
    </div>
    <div class="drop-title">Drop files here</div>
    <div class="drop-sub">Images · PDFs · Documents · Text — any format</div>
    <div style="display:flex;flex-direction:column;align-items:center;gap:12px;">
      <div style="position:relative;display:inline-block;">
        <button class="btn-browse" id="choose-photos-btn" type="button" style="pointer-events:none;">
          <svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
          Choose files
        </button>
        <!-- iOS Safari is most reliable when the user taps the real <input>. -->
        <input type="file" id="file-input-photos" multiple accept="image/*"
          style="position:absolute;inset:0;width:100%;height:100%;opacity:0;cursor:pointer;z-index:3;"
          aria-label="Choose photos" />
      </div>
      <div style="position:relative;display:inline-block;">
        <label id="choose-files-link" for="file-input-files"
          style="font-family:'DM Mono',monospace;font-size:11px;color:var(--ink-light);cursor:pointer;letter-spacing:0.08em;text-decoration:underline;">
          Browse Files app instead
        </label>
        <!-- Hidden is OK here because the user taps the associated <label>. -->
        <input type="file" id="file-input-files" multiple accept="*/*"
          style="position:absolute;left:-9999px;top:0;width:1px;height:1px;opacity:0;"
          aria-label="Browse files" />
      </div>
    </div>
  </div>

  <div id="queue"></div>

  <div id="actions" style="display:none">
    <button class="btn-primary" id="convert-btn">
      <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/></svg>
      Convert all
    </button>
    <button class="btn-secondary" id="zip-btn">
      <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Download ZIP
    </button>
    <button class="btn-secondary" id="clear-btn">Clear</button>
    <span class="queue-count" id="queue-count"></span>
  </div>
  <div id="progress-wrap"><div id="progress-bar"></div></div>

  <div id="error-log" style="display:flex;">
    <div class="error-log-header">
      <span class="error-log-title">⚑ Debug log</span>
      <button class="error-log-clear" onclick="clearErrors()">Clear</button>
    </div>
    <div id="error-entries"><div class="error-entry" style="color:var(--ink-light);">Ready — select files to see what the browser receives...</div></div>
  </div>

  <div class="info-grid">
    <div class="info-cell">
      <div class="info-cell-num">∞</div>
      <div class="info-cell-label">No server limits — bounded only by your device's memory</div>
    </div>
    <div class="info-cell">
      <div class="info-cell-num">0</div>
      <div class="info-cell-label">Files uploaded to any server — fully private</div>
    </div>
    <div class="info-cell">
      <div class="info-cell-num">q=95</div>
      <div class="info-cell-label">Default quality for lossy formats — PNG/WebP lossless available</div>
    </div>
    <div class="info-cell">
      <div class="info-cell-num">ZIP</div>
      <div class="info-cell-label">Download all converted files in one archive</div>
    </div>
  </div>
</main>

<footer>
  <div class="footer-note">All processing is local. Nothing is ever uploaded.</div>
  <div class="footer-note"><a href="https://github.com" target="_blank">View on GitHub →</a></div>
</footer>

<div id="toast"></div>

<script>
// ─── CONFIG ──────────────────────────────────────────────────────────────────

pdfjsLib.GlobalWorkerOptions.workerSrc =
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

const FORMAT_GROUPS = {
  image: {
    exts: ['png','jpg','jpeg','webp','gif','bmp','ico','tiff','tif','avif','svg','heic','heif'],
    targets: ['PNG','JPEG','WEBP','AVIF'],
    label: 'image'
  },
  pdf: {
    exts: ['pdf'],
    targets: ['PNG','JPEG','WEBP'],
    label: 'pdf'
  },
  text: {
    exts: ['txt','json','csv','md','markdown','html','htm','xml','yaml','yml','rtf','log'],
    targets: ['TXT','JSON','CSV','MD','HTML','XML'],
    label: 'text'
  }
};

const EXT_GROUP = {};
Object.entries(FORMAT_GROUPS).forEach(([g, d]) => d.exts.forEach(e => EXT_GROUP[e] = g));

// Populate format tags
const bar = document.getElementById('formats-bar');
[
  { group: 'image', items: ['PNG','JPEG','WEBP','AVIF','GIF','BMP','SVG','TIFF','HEIC'] },
  { group: 'pdf',   items: ['PDF'] },
  { group: 'text',  items: ['JSON','CSV','MD','HTML','XML','TXT','YAML'] },
].forEach(({group, items}) => {
  items.forEach(f => {
    const t = document.createElement('span');
    t.className = `format-tag ${group}`;
    t.textContent = f;
    bar.appendChild(t);
  });
});

// ─── QUEUE ───────────────────────────────────────────────────────────────────
let queue = [];
let pdfPendingResolve = null;

function ext(filename) { return filename.split('.').pop().toLowerCase(); }
function group(e) { return EXT_GROUP[e] || 'unknown'; }
function fmtBytes(b) {
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b/1024).toFixed(1) + ' KB';
  return (b/1048576).toFixed(1) + ' MB';
}

function getTargets(grp, fileExt) {
  const list = FORMAT_GROUPS[grp]?.targets || ['TXT'];
  const up = fileExt.toUpperCase();
  return list.includes(up) ? list : [up, ...list];
}

function defaultTarget(grp, fileExt) {
  const targets = getTargets(grp, fileExt);
  const up = fileExt.toUpperCase();
  return targets.find(t => t !== up) || targets[0];
}

function needsQuality(targetFmt) {
  return ['JPEG','WEBP'].includes(targetFmt);
}

async function askPdfOptions(file) {
  document.getElementById('pdf-modal-sub').textContent =
    `"${file.name}" — choose how to export pages as images.`;
  document.getElementById('pdf-modal').classList.add('open');
  return new Promise(resolve => { pdfPendingResolve = resolve; });
}

document.getElementById('pdf-confirm-btn').addEventListener('click', () => {
  const fmt = document.getElementById('pdf-out-fmt').value;
  const dpi = parseInt(document.getElementById('pdf-dpi').value) || 150;
  const pagesRaw = document.getElementById('pdf-pages').value.trim();
  document.getElementById('pdf-modal').classList.remove('open');
  if (pdfPendingResolve) pdfPendingResolve({ fmt, dpi, pages: pagesRaw });
});

document.getElementById('pdf-cancel-btn').addEventListener('click', () => {
  document.getElementById('pdf-modal').classList.remove('open');
  if (pdfPendingResolve) pdfPendingResolve(null);
});

async function addFiles(files) {
  for (const file of Array.from(files)) {
    const e = ext(file.name);
    const g = group(e);
    let pdfOpts = null;

    if (g === 'pdf') {
      pdfOpts = await askPdfOptions(file);
      if (!pdfOpts) continue; // user cancelled
    }

    const targets = getTargets(g, e);
    const tgt = pdfOpts ? pdfOpts.fmt : defaultTarget(g, e);

    queue.push({
      id: (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : 'id-' + Date.now() + '-' + Math.random().toString(36).slice(2),
      file,
      ext: e,
      group: g,
      targets,
      targetFormat: tgt,
      quality: 95,
      pdfOpts,
      status: 'ready'
    });
  }
  renderQueue();
}

function renderQueue() {
  const container = document.getElementById('queue');
  const actions = document.getElementById('actions');
  const countEl = document.getElementById('queue-count');

  container.innerHTML = '';

  queue.forEach(item => {
    const hasQ = needsQuality(item.targetFormat);
    const row = document.createElement('div');
    row.className = 'file-item';
    row.innerHTML = `
      <div class="file-info">
        <div class="file-name" title="${escHtml(item.file.name)}">${escHtml(item.file.name)}</div>
        <div class="file-meta">${fmtBytes(item.file.size)} · ${item.ext.toUpperCase()}${item.pdfOpts ? ` · ${item.pdfOpts.dpi} DPI` : ''}</div>
      </div>
      ${item.group !== 'pdf' ? `
        <select class="format-select" data-id="${item.id}" onchange="updateTarget('${item.id}',this.value)">
          ${item.targets.map(t => `<option value="${t}"${t===item.targetFormat?' selected':''}>${t}</option>`).join('')}
        </select>
      ` : `<div style="font-family:'DM Mono',monospace;font-size:11px;color:var(--ink-mid);letter-spacing:.1em;">→ ${item.targetFormat}</div>`}
      ${hasQ ? `
        <div class="quality-wrap">
          <label>Q</label>
          <input type="range" min="1" max="100" value="${item.quality}"
            oninput="updateQuality('${item.id}',+this.value,this.nextElementSibling)"/>
          <span class="quality-val">${item.quality}</span>
        </div>` : `<div></div>`}
      <span class="file-status ${item.status}">${item.status}</span>
      <button class="btn-remove" onclick="removeItem('${item.id}')" title="Remove">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>`;
    container.appendChild(row);
  });

  actions.style.display = queue.length ? 'flex' : 'none';
  countEl.textContent = `${queue.length} file${queue.length !== 1 ? 's' : ''}`;

  const zipBtn = document.getElementById('zip-btn');
  const doneCount = queue.filter(i => i.status === 'done').length;
  zipBtn.disabled = doneCount === 0;
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function updateTarget(id, val) {
  const item = queue.find(q => q.id === id);
  if (item) { item.targetFormat = val; item.status = 'ready'; renderQueue(); }
}

function updateQuality(id, val, el) {
  const item = queue.find(q => q.id === id);
  if (item) { item.quality = val; el.textContent = val; }
}

function removeItem(id) {
  queue = queue.filter(q => q.id !== id);
  renderQueue();
}

let _initialized = false;
function init() {
  if (_initialized) return;
  _initialized = true;
  logError('—', 'init', 'DOM ready — wiring elements');

  const clearBtn = document.getElementById('clear-btn');
  const convertBtn = document.getElementById('convert-btn');
  const zipBtn = document.getElementById('zip-btn');
  const dz = document.getElementById('drop-zone');
  const choosePhotosBtn = document.getElementById('choose-photos-btn');
  const chooseFilesLink = document.getElementById('choose-files-link');
  const photosInput = document.getElementById('file-input-photos');
  const filesInput = document.getElementById('file-input-files');

  if (!clearBtn || !convertBtn || !zipBtn || !dz || !choosePhotosBtn || !chooseFilesLink || !photosInput || !filesInput) {
    logError('—', 'init', `MISSING ELEMENTS: clear=${!!clearBtn} convert=${!!convertBtn} zip=${!!zipBtn} dz=${!!dz} photosBtn=${!!choosePhotosBtn} filesLink=${!!chooseFilesLink} photosIn=${!!photosInput} filesIn=${!!filesInput}`);
    return;
  }

  // File pickers are triggered by direct user taps on the actual <input>/<label> (best for iOS Safari).

  clearBtn.addEventListener('click', () => { queue = []; renderQueue(); });

  dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('drag-over'); });
  dz.addEventListener('dragleave', () => dz.classList.remove('drag-over'));
  dz.addEventListener('drop', e => {
    e.preventDefault(); dz.classList.remove('drag-over');
    receiveFiles(e.dataTransfer.files, 'drag-and-drop');
  });

  convertBtn.addEventListener('click', () => runConversions('individual'));
  zipBtn.addEventListener('click', async () => {
    const unconverted = queue.filter(i => i.status !== 'done');
    if (unconverted.length > 0) {
      await runConversions('zip');
    } else {
      const zip = new JSZip();
      queue.forEach(item => {
        if (item._result) item._result.forEach(({ blob, name }) => zip.file(name, blob));
      });
      const archive = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 1 } });
      downloadBlob(archive, `converted_${Date.now()}.zip`);
      showToast('\u2713 ZIP downloaded');
    }
  });

  function wireInput(id, source) {
    const el = document.getElementById(id);
    if (!el) { logError('—', 'init', `ERROR: element not found: ${id}`); return; }
    el.addEventListener('change', () => {
      logError('—', source, `change fired — files: ${el.files ? el.files.length : 'null'}`);
      if (!el.files || el.files.length === 0) return;
      receiveFiles(el.files, source);
      setTimeout(() => { try { el.value = ''; } catch(e2) {} }, 200);
    }, { passive: true });
    logError('—', 'init', `Wired ${id} OK`);
  }

  wireInput('file-input-photos', 'photos-picker');
  wireInput('file-input-files', 'files-picker');
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

async function receiveFiles(files, source) {
  const arr = Array.from(files);
  if (arr.length === 0) {
    logError('—', source, 'File picker returned 0 files — nothing was selected or iOS cancelled');
    return;
  }
  logError('—', source, `Received ${arr.length} file(s): ${arr.map(f => `"${f.name}" (${f.type || 'no-mime'}, ${fmtBytes(f.size)})`).join(', ')}`);
  addFiles(arr);
}

// ─── ERROR LOG ───────────────────────────────────────────────────────────────
function logError(filename, step, message) {
  const log = document.getElementById('error-log');
  const entries = document.getElementById('error-entries');
  log.style.display = 'flex';

  const entry = document.createElement('div');
  entry.className = 'error-entry';
  entry.innerHTML = `<span class="error-file">${escHtml(filename)}</span><span class="error-step">[${step}]</span>${escHtml(message)}`;
  entries.appendChild(entry);
  entries.scrollTop = entries.scrollHeight;
  console.error(`[${step}] ${filename}: ${message}`);
}

function clearErrors() {
  document.getElementById('error-entries').innerHTML = '';
  document.getElementById('error-log').style.display = 'none';
}

// ─── CONVERTERS ──────────────────────────────────────────────────────────────

function imageMime(fmt) {
  return { PNG: 'image/png', JPEG: 'image/jpeg', WEBP: 'image/webp', AVIF: 'image/avif' }[fmt] || 'image/png';
}

async function convertImage(item) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(item.file);

    logError(item.file.name, 'info', `Starting — size: ${fmtBytes(item.file.size)}, type: "${item.file.type || 'unknown mime'}", ext: ${item.ext}`);

    const img = new Image();

    img.onload = () => {
      const MAX_PIXELS = 16777216; // 16MP cap — mobile Safari limit
      let w = img.naturalWidth;
      let h = img.naturalHeight;
      if (w * h > MAX_PIXELS) {
        const scale = Math.sqrt(MAX_PIXELS / (w * h));
        w = Math.floor(w * scale);
        h = Math.floor(h * scale);
        logError(item.file.name, 'scaled', `Image too large for mobile canvas — downscaled to ${w}×${h}`);
      }
      logError(item.file.name, 'decoded', `${img.naturalWidth}×${img.naturalHeight}px — drawing to canvas`);
      try {
        const c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        const ctx = c.getContext('2d');
        if (item.targetFormat === 'JPEG') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, c.width, c.height); }
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
        const mime = imageMime(item.targetFormat);
        const q = needsQuality(item.targetFormat) ? item.quality / 100 : undefined;
        logError(item.file.name, 'exporting', `→ ${item.targetFormat} (${mime})${q !== undefined ? ` q=${q}` : ''}`);
        c.toBlob(blob => {
          if (blob) {
            logError(item.file.name, 'done', `Output: ${fmtBytes(blob.size)}`);
            resolve([blob]);
          } else {
            reject(new Error('Canvas toBlob returned null — format may not be supported'));
          }
        }, mime, q);
      } catch(e) {
        URL.revokeObjectURL(url);
        reject(new Error('Canvas error: ' + e.message));
      }
    };

    img.onerror = () => {
      URL.revokeObjectURL(url);
      const inIframe = window.self !== window.top;
      const msg = inIframe
        ? `Canvas is blocked in this preview sandbox — conversion will work on the real deployed site.`
        : `Could not decode ${item.ext.toUpperCase()} file (MIME: "${item.file.type || 'unknown'}"). Try a different browser or format.`;
      reject(new Error(msg));
    };

    img.src = url;
  });
}

function parsePdfPageRanges(raw, total) {
  if (!raw) return Array.from({length: total}, (_,i) => i+1);
  const pages = new Set();
  raw.split(',').forEach(part => {
    part = part.trim();
    if (part.includes('-')) {
      const [a, b] = part.split('-').map(Number);
      for (let i = a; i <= Math.min(b, total); i++) pages.add(i);
    } else {
      const n = parseInt(part);
      if (!isNaN(n) && n >= 1 && n <= total) pages.add(n);
    }
  });
  return [...pages].sort((a,b) => a-b);
}

async function convertPdf(item) {
  const { fmt, dpi, pages: pagesRaw } = item.pdfOpts;
  const scale = dpi / 72;
  const url = URL.createObjectURL(item.file);
  const pdf = await pdfjsLib.getDocument(url).promise;
  URL.revokeObjectURL(url);

  const pageNums = parsePdfPageRanges(pagesRaw, pdf.numPages);
  item._pageNums = pageNums; // store for filename generation
  const mime = imageMime(fmt);
  const q = needsQuality(fmt) ? item.quality / 100 : undefined;

  const MAX_PIXELS = 16777216;
  const blobs = [];

  for (const num of pageNums) {
    const page = await pdf.getPage(num);
    const vp0 = page.getViewport({ scale });
    let finalScale = scale;
    if (vp0.width * vp0.height > MAX_PIXELS) {
      finalScale = scale * Math.sqrt(MAX_PIXELS / (vp0.width * vp0.height));
      logError(item.file.name, 'pdf-scaled', `Page ${num} too large — DPI reduced to fit 16MP cap`);
    }
    const vp = page.getViewport({ scale: finalScale });
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(vp.width); canvas.height = Math.floor(vp.height);
    const ctx = canvas.getContext('2d');
    if (fmt === 'JPEG') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    const blob = await new Promise((res, rej) =>
      canvas.toBlob(b => b ? res(b) : rej(new Error('toBlob failed')), mime, q)
    );
    blobs.push(blob);
  }

  return blobs; // one blob per page
}

async function convertText(item) {
  const text = await item.file.text();
  const src = item.ext;
  const tgt = item.targetFormat;
  let out = text;

  if (src === 'json' && tgt === 'CSV') {
    try {
      const data = JSON.parse(text);
      const arr = Array.isArray(data) ? data : [data];
      if (arr.length && typeof arr[0] === 'object' && arr[0] !== null) {
        const headers = [...new Set(arr.flatMap(Object.keys))];
        out = [
          headers.join(','),
          ...arr.map(r => headers.map(h => csvEsc(r[h])).join(','))
        ].join('\n');
      } else {
        out = arr.map(v => String(v)).join('\n');
      }
    } catch { /* keep original */ }
  } else if (src === 'csv' && tgt === 'JSON') {
    const rows = parseCSV(text);
    out = JSON.stringify(rows, null, 2);
  } else if (tgt === 'HTML' && (src === 'md' || src === 'markdown')) {
    out = mdToHtml(text);
  } else if (tgt === 'MD' && (src === 'html' || src === 'htm')) {
    out = htmlToMd(text);
  } else if (tgt === 'TXT') {
    out = text.replace(/<[^>]+>/g, '').replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&nbsp;/g,' ');
  } else if (tgt === 'JSON' && (src === 'yaml' || src === 'yml')) {
    // Basic YAML key: value → JSON (flat only)
    try {
      const obj = {};
      text.split('\n').forEach(line => {
        const m = line.match(/^([^:#]+):\s*(.+)/);
        if (m) { try { obj[m[1].trim()] = JSON.parse(m[2].trim()); } catch { obj[m[1].trim()] = m[2].trim(); } }
      });
      out = JSON.stringify(obj, null, 2);
    } catch { /* keep */ }
  } else if (tgt === 'XML' && src === 'json') {
    try {
      const obj = JSON.parse(text);
      out = jsonToXml(obj, 'root');
    } catch { /* keep */ }
  }

  const mimeFor = {
    TXT: 'text/plain', JSON: 'application/json', CSV: 'text/csv',
    MD: 'text/markdown', HTML: 'text/html', XML: 'application/xml'
  };
  return [new Blob([out], { type: mimeFor[tgt] || 'text/plain' })];
}

function csvEsc(v) {
  if (v === undefined || v === null) return '';
  const s = String(v);
  return s.includes(',') || s.includes('"') || s.includes('\n') ? `"${s.replace(/"/g,'""')}"` : s;
}

function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g,''));
  return lines.slice(1).filter(Boolean).map(line => {
    const vals = line.split(',').map(v => v.trim().replace(/^"|"$/g,''));
    return Object.fromEntries(headers.map((h, i) => [h, vals[i] ?? '']));
  });
}

function mdToHtml(md) {
  let html = md
    .replace(/^#{6}\s(.+)$/gm, '<h6>$1</h6>')
    .replace(/^#{5}\s(.+)$/gm, '<h5>$1</h5>')
    .replace(/^#{4}\s(.+)$/gm, '<h4>$1</h4>')
    .replace(/^###\s(.+)$/gm, '<h3>$1</h3>')
    .replace(/^##\s(.+)$/gm, '<h2>$1</h2>')
    .replace(/^#\s(.+)$/gm, '<h1>$1</h1>')
    .replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>')
    .replace(/\x60{3}[\s\S]*?\x60{3}/g, m => `<pre><code>${escHtml(m.slice(3,-3).replace(/^\w+\n/,''))}</code></pre>`)
    .replace(/\x60([^\x60]+)\x60/g, '<code>$1</code>')
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
    .replace(/^>\s(.+)$/gm, '<blockquote>$1</blockquote>')
    .replace(/^[-*+]\s(.+)$/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>\n?)+/g, m => `<ul>${m}</ul>`)
    .replace(/\n\n/g, '</p><p>');
  return `<!DOCTYPE html>\n<html lang="en">\n<head><meta charset="UTF-8"><title>Document</title></head>\n<body>\n<p>${html}</p>\n</body>\n</html>`;
}

function htmlToMd(html) {
  return html
    .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n')
    .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\n\n')
    .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\n\n')
    .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\n\n')
    .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
    .replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**')
    .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
    .replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*')
    .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, '[$2]($1)')
    .replace(/<code[^>]*>(.*?)<\/code>/gi, '`$1`')
    .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n')
    .replace(/<[^>]+>/g, '')
    .replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&nbsp;/g,' ')
    .replace(/\n{3,}/g, '\n\n').trim();
}

function jsonToXml(obj, tagName) {
  if (Array.isArray(obj)) {
    return obj.map(v => `<item>${typeof v === 'object' ? jsonToXml(v, 'item') : v}</item>`).join('');
  }
  if (typeof obj === 'object' && obj !== null) {
    return Object.entries(obj).map(([k, v]) => {
      const tag = k.replace(/[^a-zA-Z0-9_\-]/g, '_');
      return `<${tag}>${typeof v === 'object' ? jsonToXml(v, tag) : v}</${tag}>`;
    }).join('');
  }
  return String(obj);
}

// ─── MAIN CONVERT ─────────────────────────────────────────────────────────────

async function convertItem(item) {
  if (item.group === 'image') return convertImage(item);
  if (item.group === 'pdf')   return convertPdf(item);
  if (item.group === 'text')  return convertText(item);
  return [item.file]; // pass-through
}

function getOutputFilenames(item, blobs, pageNums) {
  const base = item.file.name.replace(/\.[^.]+$/, '');
  const fmtLower = item.targetFormat.toLowerCase();
  if (item.group === 'pdf' && blobs.length > 1) {
    return blobs.map((_, i) => `${base}_p${String(pageNums ? pageNums[i] : i + 1).padStart(3, '0')}.${fmtLower}`);
  }
  return [`${base}.${fmtLower}`];
}

function downloadBlob(blob, name) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 3000);
}

async function runConversions(downloadMode) {
  const convertBtn = document.getElementById('convert-btn');
  const zipBtn = document.getElementById('zip-btn');
  const progressWrap = document.getElementById('progress-wrap');
  const progressBar = document.getElementById('progress-bar');

  convertBtn.disabled = zipBtn.disabled = true;
  progressWrap.style.display = 'block';

  const total = queue.length;
  let done = 0;

  // Collect results for ZIP
  const zipEntries = []; // { name, blob }

  for (const item of queue) {
    item.status = 'converting';
    renderQueue();

    try {
      const blobs = await convertItem(item);
      const names = getOutputFilenames(item, blobs, item._pageNums);
      item.status = 'done';
      item._result = blobs.map((b, i) => ({ blob: b, name: names[i] }));

      if (downloadMode === 'individual') {
        for (const { blob, name } of item._result) {
          downloadBlob(blob, name);
          await new Promise(r => setTimeout(r, 60));
        }
      } else {
        for (const entry of item._result) zipEntries.push(entry);
      }
    } catch (err) {
      console.error(err);
      logError(item.file.name, 'failed', err.message);
      item.status = 'error';
    }

    done++;
    progressBar.style.width = `${(done / total) * 100}%`;
    renderQueue();
  }

  if (downloadMode === 'zip' && zipEntries.length) {
    const zip = new JSZip();
    zipEntries.forEach(({ blob, name }) => zip.file(name, blob));
    const archive = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 1 } });
    downloadBlob(archive, `converted_${Date.now()}.zip`);
  }

  convertBtn.disabled = false;
  convertBtn.innerHTML = `
    <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/></svg>
    Convert all`;

  const succeeded = queue.filter(i => i.status === 'done').length;
  const failed = queue.filter(i => i.status === 'error').length;
  showToast(failed === 0
    ? `✓ ${succeeded} file${succeeded !== 1 ? 's' : ''} converted`
    : `${succeeded} converted · ${failed} failed`);

  setTimeout(() => {
    progressBar.style.width = '0%';
    progressWrap.style.display = 'none';
    renderQueue();
  }, 1600);
}



// ─── TOAST ───────────────────────────────────────────────────────────────────
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 3200);
}
</script>
</body>
</html>
